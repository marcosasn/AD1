---
title: "Problema 3 - Checkpoint 2"
author: Marcos Antonio Silva Nascimento (marcos.nascimento@ccc.ufcg.edu.br)
date: "16 de junho de 2017"
output: html_document
---
```{r setup, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load_code}
require(GGally, quietly = TRUE)
require(reshape2, quietly = TRUE)
require(tidyverse, quietly = TRUE, warn.conflicts = FALSE)

library(ggfortify)
library(cluster)
library(ggdendro)
library(broom)
library(plotly)
library(readr)
library(magrittr)

theme_set(theme_bw())
```
#Tipos de filme quanto ao gênero do personagem e da quantidade de palavras que eles falam
Neste post vamos investigar a existência de tipos de filmes quanto ao gênero do personagem e da quantidade de palavras que ele fala. Esta investigação vai ajudar as pessoas a se confrontarem com o que se conhece popularmente a respeito de filmes voltados para o público feminino e os filmes do gênero de terror, por exemplo. Será que existem grupos que definem comportamentos comuns para os filmes analisados? Utilizaremos os dados cedidos pelo [Github](https://github.com/matthewfdaniels/scripts).

```{r}
personagens = read_csv(file = "../dados/film-dialogue/character_list5.csv")
personagens = personagens %>%
  filter(age != 'NULL') %>% 
  mutate(age = as.numeric(age))

filmes = read.csv(file = "../dados/film-dialogue/meta_data7.csv")
filmes = filmes %>%
  filter(gross != 'NA')

filmes_personagens = merge(filmes, personagens, by="script_id")

mulheres = filmes_personagens %>%
  filter(gender == 'f') %>%
  group_by(script_id, imdb_id, title, year, gross) %>%
  summarise(n_f=n(), words_f=median(words))

homens = filmes_personagens %>%
  filter(gender == 'm') %>%
  group_by(script_id, imdb_id, title, year, gross) %>%
  summarise(n_m=n(), words_m=median(words))

dados = merge(mulheres, homens, 
                           by=c('script_id','imdb_id','title','year','gross'))
duplicados = dados %>%
  group_by(title) %>% filter(row_number() > 1)

dados = dados %>% 
  filter(!(title %in% duplicados$title))
  
dados = dados %>%
  subset(select = -c(script_id,imdb_id,year,gross))
```
##Decisões sobre filtrar dados ou variáveis
Observando os dados cedidos pelo repositório pude notar que o valor da variável idade, da tabela de personagens, não estava disponível ou continha valor nulo. Desta forma foi feita a filtragem dessas observações. A variável renda da tabela dos filmes tinha comportamento semelhente. Algumas observações continha valor não disponível então eu achei que seria prudente filtra-los uma vez que, filmes sem valor de renda não seriam relavantes na análise.

Uma limitação encontrada durante a análise foi o fato de alguns filmes possuirem o mesmo nome embora fossem diferentes então para submeter os dados para a análise eu tive que fazer a filtragem desses filmes com nomes repetidos também. 

##As dimensões submetidas a análise
As dimensões submetidas a análise foram 4 variáveis numéricas calculadas a partir do conjunto de dados cedido pelo Github mencionado acima. São elas: nº de personagens do sexo feminino no filme, mediana de palavras dos personagens do sexo feminino no filme, nº de personagens do sexo masculino no filme, mediana de palavras dos personagens do sexo masculino no filme.

O conjunto de dados submetido a análise contém, para cada filme, uma observação com valores para cada variável mencionada acima. A escolha das variáveis acima visava obter a resposta para a seguinte pergunta: visando o gênero do personagem e a quantidade de palavras ditas por ele em um filme, quais os tipos de filmes?

##Sumário e descrição dos dados
Vamos primeiramente olhar para o gráfico abaixo, veja como se comporta a distribuição de cada dimensão dos dados.

###Dados brutos
```{r}
dw = dados

dw %>% 
  select(-title) %>% 
  ggpairs(columnLabels = c("Nº mulheres",
                           "Palavras mulheres",
                           "Nº homens",
                           "Palavras homens"),
          title = "Distribuição e correlação das dimensões")+
  theme(plot.title = element_text(hjust = 0.5))
```
```{r}
summary(select(dw, -title))
```
###Dados em escala de log
```{r}
# Escala de log 
dw2 <- dw %>% 
    mutate_each(funs(log), 2:5)

dw2 %>% 
    select(-title) %>% 
    ggpairs(columnLabels = c("Nº mulheres",
                           "Palavras mulheres",
                           "Nº homens",
                           "Palavras homens"),
          title = "Distribuição e correlação das dimensões")+
  theme(plot.title = element_text(hjust = 0.5))
```
```{r}
summary(select(dw2, -title))
```


###Dados padronizados
```{r}
dw2.scaled = dw2 %>% 
  mutate_each(funs(as.vector(scale(.))), 2:5)

dw2.scaled %>% 
    select(-title) %>% 
    ggpairs(columnLabels = c("Nº mulheres",
                           "Palavras mulheres",
                           "Nº homens",
                           "Palavras homens"),
          title = "Distribuição e correlação das dimensões")+
  theme(plot.title = element_text(hjust = 0.5))
```
```{r}
summary(select(dw2.scaled, -title))
```

```{r}
dists = dw2.scaled %>%
      column_to_rownames("title") %>% 
    dist(method = "euclidean")

hc = hclust(dists, method = "ward.D")

n_clusters = 4

dw2 <- dw2 %>% 
    mutate(cluster = hc %>% 
               cutree(k = n_clusters) %>% 
               as.character())

dw2.scaled <- dw2.scaled %>% 
    mutate(cluster = hc %>% 
               cutree(k = n_clusters) %>% 
               as.character())

dw2.long = melt(dw2.scaled, id.vars = c("title", "cluster"))
```

#O agrupamento multidimensional utilizado o algoritmo k-means
```{r}
dw2.scaled = dw2.scaled %>% 
    select(-cluster) # Remove o cluster adicionado antes lá em cima via hclust

# O agrupamento de fato:
km = dw2.scaled %>% 
    select(-title) %>% 
    kmeans(centers = n_clusters, nstart = 20)

# O df em formato longo, para visualização 
dw2.scaled.km.long = km %>% 
    augment(dw2.scaled) %>% # Adiciona o resultado de km 
                            # aos dados originais dw2.scaled em 
                            # uma variável chamada .cluster
    gather(key = "variável", 
           value = "valor", 
           -title, -.cluster) # = move para long todas as 
                                            # variávies menos repository_language 
                                            # e .cluster
dw2.scaled.km.long %>% 
    ggplot(aes(x = `variável`, y = valor, group = title, colour = .cluster)) + 
    #geom_point(alpha = 0.2) + 
    geom_line(alpha = .5) + 
    facet_wrap(~ .cluster) 

autoplot(km, data = dw2.scaled, label = TRUE)

dists = dw2.scaled %>% 
    select(-title) %>% 
    dist() # só para plotar silhouetas depois
#plot(silhouette(km$cluster, dists), col = RColorBrewer::brewer.pal(n_clusters, "Set2"))
```

```{r}
#summary(dw2.scaled)
p <- km %>% 
    augment(dw2.scaled) %>%
    plot_ly(type = 'parcoords',
            line = list(color = ~.cluster, 
                        showScale = TRUE),
            dimensions = list(
                #list(range = c(1, 4), label = "cluster", values = ~cluster),
                list(range = c(-3, 3),
                     label = 'n_f', values = ~n_f),
                list(range = c(-3, 3),
                     label = 'words_f', values = ~words_f),
                list(range = c(-6, 3),
                     label = 'n_m', values = ~n_m),
                list(range = c(-2, 3),
                     label = 'words_m', values = ~words_m)
            )
    )
p
```

Qual seria um bom valor de k? Uma medida comumente usada no kmeans é comparar a distância (quadrática) entre o centro dos clusters e o centro dos dados com a distância (quadrática) entre os pontos todos nos dados e o centro dos dados. Aqui o centro dos dados é um ponto imaginário na média de todas as variáveis. Calculamos a distância do centro de cada cluster para o centro dos dados e multiplicamos pelo número de pontos nesse cluster. Somando esse valor para todos os clusters, temos betweenss abaixo. Se esse valor for próximo do somatório total das distâncias dos pontos para o centro dos dados (totss), os pontos estão próximos do centro de seu cluster. Essa proporção pode ser usada para definir um bom valor de k. Quando ela para de crescer, para de valer à pena aumentar k.

```{r}
set.seed(123)
explorando_k = tibble(k = 1:15) %>% 
    group_by(k) %>% 
    do(
        kmeans(select(dw2.scaled, -title), 
               centers = .$k, 
               nstart = 20) %>% glance()
    )

explorando_k %>% 
    ggplot(aes(x = k, y = betweenss / totss)) + 
    geom_line() + 
    geom_point()
```

#Conclusão

[Marcos Nascimento](http://https://github.com/marcosasn/AD1/tree/master/problema3/R)