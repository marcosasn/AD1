---
title: "Problema 3 - Checkpoint 2"
author: Marcos Antonio Silva Nascimento (marcos.nascimento@ccc.ufcg.edu.br)
date: "16 de junho de 2017"
output: html_document
---
```{r setup, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load_code}
require(GGally, quietly = TRUE)
require(reshape2, quietly = TRUE)
require(tidyverse, quietly = TRUE, warn.conflicts = FALSE)

library(ggfortify)
library(cluster)
library(ggdendro)
library(broom)
library(plotly)
library(readr)
library(magrittr)

theme_set(theme_bw())
```
#Tipos de filme quanto ao gênero do personagem e da quantidade de palavras que eles falam
Neste post vamos investigar a existência de tipos de filmes quanto ao gênero do personagem e da quantidade de palavras que ele fala. Esta investigação vai ajudar as pessoas a se confrontarem com o que se conhece popularmente a respeito de filmes voltados para o público feminino e os filmes do gênero de terror, por exemplo. Será que existem grupos que definem comportamentos comuns para os filmes analisados? Utilizaremos os dados cedidos pelo [Github](https://github.com/matthewfdaniels/scripts).

```{r}
personagens = read_csv(file = "../dados/film-dialogue/character_list5.csv")
personagens = personagens %>%
  filter(age != 'NULL') %>% 
  mutate(age = as.numeric(age))

filmes = read.csv(file = "../dados/film-dialogue/meta_data7.csv")
filmes = filmes %>%
  filter(gross != 'NA')

filmes_personagens = merge(filmes, personagens, by="script_id")

mulheres = filmes_personagens %>%
  filter(gender == 'f') %>%
  group_by(script_id, imdb_id, title, year, gross) %>%
  summarise(n_f=n(), words_f=median(words))

homens = filmes_personagens %>%
  filter(gender == 'm') %>%
  group_by(script_id, imdb_id, title, year, gross) %>%
  summarise(n_m=n(), words_m=median(words))

dados = merge(mulheres, homens, 
                           by=c('script_id','imdb_id','title','year','gross'))
duplicados = dados %>%
  group_by(title) %>% filter(row_number() > 1)

dados = dados %>% 
  filter(!(title %in% duplicados$title))
  
dados = dados %>%
  subset(select = -c(script_id,imdb_id,year,gross))
```
##Decisões sobre filtrar dados ou variáveis
Observando os dados cedidos pelo repositório pude notar que o valor da variável idade, da tabela de personagens, não estava disponível ou continha valor nulo. Desta forma foi feita a filtragem dessas observações. A variável renda da tabela dos filmes tinha comportamento semelhente. Algumas observações continha valor não disponível então eu achei que seria prudente filtra-los uma vez que, filmes sem valor de renda não seriam relavantes na análise.

Uma limitação encontrada durante a análise foi o fato de alguns filmes possuirem o mesmo nome embora fossem diferentes então para submeter os dados para a análise eu tive que fazer a filtragem desses filmes com nomes repetidos também. 

##As dimensões submetidas a análise
As dimensões submetidas a análise foram 4 variáveis numéricas calculadas a partir do conjunto de dados cedido pelo Github mencionado acima. São elas: nº de personagens do sexo feminino no filme, mediana de palavras dos personagens do sexo feminino no filme, nº de personagens do sexo masculino no filme, mediana de palavras dos personagens do sexo masculino no filme.

O conjunto de dados submetido a análise contém, para cada filme, uma observação com valores para cada variável mencionada acima. A escolha das variáveis acima visava obter a resposta para a seguinte pergunta: visando o gênero do personagem e a quantidade de palavras ditas por ele em um filme, quais os tipos de filmes?

##Sumário e descrição dos dados
Vamos primeiramente olhar para o gráfico abaixo, veja como se comporta a distribuição de cada dimensão dos dados.

###Dados brutos
```{r}
dw = dados

dw %>% 
  select(-title) %>% 
  ggpairs(columnLabels = c("Nº mulheres",
                           "Palavras mulheres",
                           "Nº homens",
                           "Palavras homens"),
          title = "Distribuição e correlação das dimensões")+
  theme(plot.title = element_text(hjust = 0.5))
```

Na diagonal do gráfico acima podemos observar a distribuição de cada uma das dimensões submetidas a análise. De primeira já podemos observar um viesamento dos dados a esquerda. Isto impede ver melhor a magnitude dos valores porque os mesmo se concentram a esquerda do gráfico. De ante mão já podemos identificar que o número de homens nos filmes é ligeiramente maior que o número de mulheres. Isto fica ainda mais evidente no sumário dos dados abaixo, em termos de mediana, o número de homens nos filmes é duas vezes maior que o número de mulheres.

Embora possa ser contraditório, a mediana de palavras ditas pelas mulheres é um pouco superior a mediana de palavras ditas pelos homens. Isto fica ainda mais evidente no sumário abaixo.

Ainda sobre o gráfico a cima podemos observar que a medida que o número de mulheres ou homens presentes nos filmes aumenta eles tendem a falar menos em termos de mediana. No que diz respeito a correlação não podemos observar nenhuma correlação forte positiva ou negativa entre cada uma das dimensões analisadas.
```{r}
summary(select(dw, -title))
```
###Dados em escala de log
Como foi dito na seção anterior, é aconselhável observar a distruibuição de cada uma das dimensões na escala logarítmica para observar melhor a magnitude dos valores que se enviesam ou se concentram a esquerda do gráfico.
```{r}
# Escala de log 
dw2 <- dw %>% 
    mutate_each(funs(log), 2:5)

dw2 %>% 
    select(-title) %>% 
    ggpairs(columnLabels = c("Nº mulheres",
                           "Palavras mulheres",
                           "Nº homens",
                           "Palavras homens"),
          title = "Distribuição e correlação das dimensões")+
  theme(plot.title = element_text(hjust = 0.5))
```
As conclusões sobre a figura acima são quase as mesmas para a figura da seção anterior mas a atenção se volta parar o gráfico de mediana de palavras das mulheres e a mediana de palavras dos homens. Na seção anterior percebemos que as mulheres falavam mais palavras do que os homens apesar de o número de mulheres ser duas vezes menor do que o número de homens, neste gráfico vemos que esta diferença é quase imperceptível. Isto fica ainda mais evidente no sumário de dados abaixo.

```{r}
summary(select(dw2, -title))
```

###Dados padronizados
Depois de analisar os dados brutos e na escala logarítmica é chegada a hora de ver como se comporta a distribuição dos dados padronizados ou normalizados.
```{r}
dw2.scaled = dw2 %>% 
  mutate_each(funs(as.vector(scale(.))), 2:5)

dw2.scaled %>% 
    select(-title) %>% 
    ggpairs(columnLabels = c("Nº mulheres",
                           "Palavras mulheres",
                           "Nº homens",
                           "Palavras homens"),
          title = "Distribuição e correlação das dimensões")+
  theme(plot.title = element_text(hjust = 0.5))
```

O comportamento da distribuição de cada uma dimensão agora está em torno da média de cada dimensão. Como podemos observar nos gráficos acima e no sumário abaixo a média de cada dimensão é zero (própria da distribuição normal com média zero) e os demais valores são distanciamentos da média. Isto facilitará a análise dos gráficos de agrupamento nas seções posteriores.

Uma vez normalizados ou padronizados, os dados podem ser utilizados no processo de agrupamento de forma igualitária ou justa (estaremos agrupando dados ou variáveis na mesma escala).
```{r}
summary(select(dw2.scaled, -title))
```

#O agrupamento multidimensional utilizado o algoritmo k-means
##Escolhendo o valor de k
Antes de realizar o agrupamento precisamos escolher um bom valor para k (basicamente indica o número de grupos ou tipos que iremos identificar no conjunto de dados). Uma medida comumente usada no k-means é comparar a distância (quadrática) entre o centro dos clusters e o centro dos dados com a distância (quadrática) entre os pontos todos nos dados e o centro dos dados.

Aqui o centro dos dados é um ponto imaginário na média de todas as variáveis. Calculamos a distância do centro de cada cluster para o centro dos dados e multiplicamos pelo número de pontos nesse cluster. Somando esse valor para todos os clusters, temos betweenss abaixo. Se esse valor for próximo do somatório total das distâncias dos pontos para o centro dos dados (totss), os pontos estão próximos do centro de seu cluster. Essa proporção pode ser usada para definir um bom valor de k. Quando ela para de crescer, para de valer à pena aumentar k.
```{r}
dists = dw2.scaled %>%
      column_to_rownames("title") %>% 
    dist(method = "euclidean")

hc = hclust(dists, method = "ward.D")

n_clusters = 4

dw2 <- dw2 %>% 
    mutate(cluster = hc %>% 
               cutree(k = n_clusters) %>% 
               as.character())

dw2.scaled <- dw2.scaled %>% 
    mutate(cluster = hc %>% 
               cutree(k = n_clusters) %>% 
               as.character())

dw2.long = melt(dw2.scaled, id.vars = c("title", "cluster"))

dw2.scaled = dw2.scaled %>% 
    select(-cluster) # Remove o cluster adicionado antes lá em cima via hclust

set.seed(123)
explorando_k = tibble(k = 1:15) %>% 
    group_by(k) %>% 
    do(
        kmeans(select(dw2.scaled, -title), 
               centers = .$k, 
               nstart = 20) %>% glance()
    )

explorando_k %>% 
    ggplot(aes(x = k, y = betweenss / totss)) + 
    geom_line() + 
    geom_point()

```

##Agrupando os dados utilizando k encontrado
```{r}
# O agrupamento de fato:
km = dw2.scaled %>% 
    select(-title) %>% 
    kmeans(centers = n_clusters, nstart = 20)

# O df em formato longo, para visualização 
dw2.scaled.km.long = km %>% 
    augment(dw2.scaled) %>% # Adiciona o resultado de km 
                            # aos dados originais dw2.scaled em 
                            # uma variável chamada .cluster
    gather(key = "variável", 
           value = "valor", 
           -title, -.cluster) # = move para long todas as 
                                            # variávies menos repository_language 
                                            # e .cluster
dw2.scaled.km.long %>% 
    ggplot(aes(x = `variável`, y = valor, group = title, colour = .cluster)) + 
    #geom_point(alpha = 0.2) + 
    geom_line(alpha = .5) + 
    facet_wrap(~ .cluster) 

autoplot(km, data = dw2.scaled, label = TRUE)

dists = dw2.scaled %>% 
    select(-title) %>% 
    dist() # só para plotar silhouetas depois
#plot(silhouette(km$cluster, dists), col = RColorBrewer::brewer.pal(n_clusters, "Set2"))
```

```{r}
p <- km %>% 
    augment(dw2.scaled) %>%
    plot_ly(type = 'parcoords',
            line = list(color = ~.cluster, 
                        showScale = TRUE),
            dimensions = list(
                #list(range = c(1, 4), label = "cluster", values = ~cluster),
                list(range = c(-3, 3),
                     label = 'n_f', values = ~n_f),
                list(range = c(-3, 3),
                     label = 'words_f', values = ~words_f),
                list(range = c(-6, 3),
                     label = 'n_m', values = ~n_m),
                list(range = c(-2, 3),
                     label = 'words_m', values = ~words_m)
            )
    )
p
```

[Marcos Nascimento](http://https://github.com/marcosasn/AD1/tree/master/problema3/R)